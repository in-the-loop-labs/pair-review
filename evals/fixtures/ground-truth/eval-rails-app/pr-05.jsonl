{"id": "05-001", "file": "app/jobs/task_notification_job.rb", "line_start": 7, "line_end": 9, "type": "bug", "severity": "high", "title": "Race condition — job does not handle deleted or changed tasks", "description": "Task.find(task_id) on line 8 will raise ActiveRecord::RecordNotFound if the task is deleted between enqueueing and execution. The job also doesn't verify the task is still in the state that triggered the notification (e.g., the assignee may have already changed). Background jobs should always handle stale references gracefully.", "hint": "Wrap in Task.find_by(id: task_id) with an early return if nil, or rescue ActiveRecord::RecordNotFound. Optionally verify the task still matches the expected state."}
{"id": "05-002", "file": "app/jobs/task_notification_job.rb", "line_start": 4, "line_end": 5, "type": "improvement", "severity": "medium", "title": "No retry or error handling configuration on the job", "description": "The job has no retry_on, discard_on, or rescue blocks. If notification delivery fails (e.g., database error, external service timeout), the job silently falls through to Sidekiq's default retry behavior with no application-level logging or error handling. Jobs should be explicit about their retry strategy.", "hint": "Add retry_on for transient errors and discard_on ActiveRecord::RecordNotFound. Add error logging in a rescue block.", "is_file_level": true}
{"id": "05-003", "file": "app/jobs/task_notification_job.rb", "line_start": 11, "line_end": 53, "type": "design", "severity": "medium", "title": "Business logic in job violates service object convention", "description": "The job contains all notification logic: determining recipients, formatting messages, and choosing delivery methods. The project's CONTRIBUTING.md requires business logic to live in service objects, not jobs or controllers. The job should orchestrate by calling a NotificationService, keeping itself thin.", "hint": "Extract a NotificationService that accepts (task, event_type, triggered_by) and returns notifications. The job should only call the service and handle job-level concerns (retries, logging)."}
{"id": "05-004", "file": "app/models/task.rb", "line_start": 31, "line_end": 38, "type": "bug", "severity": "medium", "title": "No deduplication — callback fires on every save, producing duplicate notifications", "description": "The after_save callback enqueues a notification job whenever user_id or status changes, but there is no guard against duplicate notifications. If a task is saved multiple times in quick succession (e.g., bulk update, form double-submit, or a service that updates multiple attributes in separate saves), duplicate notification jobs are enqueued for the same logical event.", "hint": "Track whether a notification was already enqueued for this save cycle, or add a unique constraint/check in the job itself to prevent duplicate notifications."}
{"id": "05-005", "file": "app/jobs/task_notification_job.rb", "line_start": 25, "line_end": 25, "type": "performance", "severity": "medium", "title": "Notifies ALL users on status change instead of project members only", "description": "Line 25 uses User.all to determine recipients for status_changed notifications. This sends notifications to every user in the system, not just members of the project the task belongs to. In a system with thousands of users, this creates thousands of unnecessary notification records and database writes.", "hint": "Replace User.all with the task's project members, e.g., User.joins(:projects).where(projects: { id: task.project_id }) or a project.members scope."}
{"id": "05-006", "file": "app/jobs/task_notification_job.rb", "line_start": 58, "line_end": 72, "type": "code-style", "severity": "low", "title": "Three private methods doing the same thing with inconsistent names", "description": "deliver_message (line 58), send_notification (line 64), and notify_user (line 69) all do exactly the same thing — update read to false and log. Using three different names for identical behavior violates DRY and makes the code confusing. The naming is also inconsistent with Rails conventions.", "hint": "Consolidate into a single method (e.g., deliver_notification) and call it from all three event branches."}
{"id": "05-007", "file": "app/models/notification.rb", "line_start": 4, "line_end": 8, "type": "design", "severity": "low", "title": "Notification model has no scopes, validations, or business methods", "description": "The Notification model only declares associations — no validations (e.g., action inclusion), no scopes (e.g., unread, for_user, recent), and no business methods. Compare with the Task and Project models which have rich scope definitions and validations. This makes querying notifications verbose and error-prone in controllers and views.", "hint": "Add validates :action, inclusion: { in: %w[assigned status_changed commented due_date_reminder] }. Add scopes like scope :unread, -> { where(read: false) } and scope :for_user, ->(user) { where(recipient: user) }."}
{"id": "05-008", "file": "app/jobs/due_date_reminder_job.rb", "line_start": 14, "line_end": 20, "type": "bug", "severity": "medium", "title": "Due date reminder creates duplicate notifications on repeated runs", "description": "The job does not check whether a due_date_reminder notification already exists for a given task and recipient. If the job runs multiple times per day (e.g., via a cron schedule that fires more than once, or a manual re-run), it creates duplicate reminder notifications for the same task.", "hint": "Add a check like `unless Notification.exists?(task: task, recipient: task.user, action: 'due_date_reminder', created_at: Date.current.all_day)` before creating."}
{"id": "05-009", "file": "db/migrate/20240215000001_create_notifications.rb", "line_start": 6, "line_end": 15, "type": "performance", "severity": "low", "title": "Missing database index on read status for efficient unread queries", "description": "The notifications table has no index on the :read column or a composite index on [:recipient_id, :read]. Querying unread notifications for a user (a very common operation) will require a full table scan as the table grows. The recipient_id index alone is insufficient when filtering by read status.", "hint": "Add `add_index :notifications, [:recipient_id, :read]` or `add_index :notifications, :read` to the migration."}
