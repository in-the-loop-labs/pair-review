{"id": "09-001", "file": "app/controllers/dashboard_controller.rb", "line_start": 9, "line_end": 14, "type": "performance", "severity": "high", "title": "Loads all task records into memory instead of using aggregate queries", "description": "Line 9 uses @projects.flat_map(&:tasks) to load every task record into Ruby memory, then lines 11-14 iterate the array multiple times to compute counts. For a user with hundreds of projects and thousands of tasks, this loads all Task objects into memory and scans the entire array four times. ActiveRecord provides efficient alternatives: Task.where(project: @projects).group(:status).count produces a single SQL GROUP BY query that returns counts without instantiating any model objects. The same pattern applies to the priority breakdown (lines 30-33) and weekly/monthly counts (lines 20-22, 43-45).", "hint": "Replace flat_map(&:tasks) with aggregate queries. Use Task.where(project: @projects).group(:status).count for status breakdown, .group(:priority).count for priority breakdown, and .where(conditions).count for filtered counts."}
{"id": "09-002", "file": "app/controllers/dashboard_controller.rb", "line_start": 17, "line_end": 17, "type": "bug", "severity": "low", "title": "Division by zero when user has no tasks", "description": "Line 17 computes @completed_tasks.to_f / @total_tasks * 100 — if @total_tasks is 0 (new user with no tasks, or all projects are empty), this divides by zero. In Ruby, 0.0 / 0 produces NaN (since both operands become floats via .to_f), and NaN.round(1) returns NaN, which will render as 'NaN' in the view. The same issue exists on line 56 for per-project completion_rate where a project with zero tasks will also produce NaN.", "hint": "Guard against zero: @total_tasks.zero? ? 0.0 : (@completed_tasks.to_f / @total_tasks * 100).round(1). Apply the same guard on line 56."}
{"id": "09-003", "file": "app/controllers/dashboard_controller.rb", "line_start": 21, "line_end": 21, "type": "bug", "severity": "high", "title": "Date.today uses system timezone instead of Rails configured timezone", "description": "Lines 21, 25, and 57 use Date.today which returns the date in the server's system timezone, ignoring Rails' configured Time.zone. If the Rails app is configured with config.time_zone = 'Eastern Time (US & Canada)' but the server runs in UTC, Date.today at 11pm Eastern (which is 4am UTC the next day) returns tomorrow's date. This causes tasks completed today to not count as 'this week', overdue calculations to be off by a day, etc. The Task model's own scopes (line 30 of task.rb) correctly use Date.current.", "hint": "Replace all Date.today with Date.current (or Time.current.to_date) which respects Rails' Time.zone configuration. This is consistent with the existing Task model scopes."}
{"id": "09-004", "file": "app/controllers/dashboard_controller.rb", "line_start": 5, "line_end": 60, "type": "design", "severity": "medium", "title": "Controller action contains 55 lines of data transformation and presentation logic", "description": "The entire index action is a single method performing data loading, aggregation, percentage calculations, date filtering, and per-project statistics assembly. This violates the single-responsibility principle and the project's convention of using service objects for business logic (see CONTRIBUTING.md). Controllers should be thin — delegating to a service, presenter, or view model for data preparation. The method is also difficult to unit test since it requires a full request cycle.", "hint": "Extract a DashboardPresenter or DashboardService that accepts the current user and returns a structured data object with all computed statistics. The controller action should be 2-3 lines: instantiate the presenter, call it, and assign instance variables (or pass the presenter directly to the view)."}
{"id": "09-005", "file": "app/controllers/dashboard_controller.rb", "line_start": 37, "line_end": 40, "type": "performance", "severity": "medium", "title": "Redundant database query for recent activity when tasks are already loaded", "description": "Lines 37-40 execute a separate database query (Task.where(project: current_user.projects)) to fetch recent activity, even though all tasks for the user's projects were already loaded into memory on line 9 via flat_map(&:tasks). This is doubly wasteful: the data is already in memory but a new query is issued, and the new query doesn't benefit from the includes(:tasks) on the projects. Either use the already-loaded data (sorted and limited in Ruby) or, better yet, replace the in-memory approach entirely with targeted database queries.", "hint": "If keeping the in-memory approach, sort and slice the already-loaded tasks: all_tasks.sort_by(&:updated_at).reverse.first(10). If refactoring to use database queries throughout, this query is fine but the flat_map approach should be removed."}
{"id": "09-006", "file": "app/controllers/dashboard_controller.rb", "line_start": 56, "line_end": 56, "type": "bug", "severity": "low", "title": "Division by zero in per-project completion rate for empty projects", "description": "Line 56 computes completed.to_f / total * 100 where total is the number of tasks in a project. A project with no tasks has total = 0, causing the same NaN issue as line 17. This is the per-project variant of the same bug, and will render 'NaN%' in the project breakdown table.", "hint": "Add a zero guard: total.zero? ? 0.0 : (completed.to_f / total * 100).round(1)"}
{"id": "09-007", "file": "app/controllers/dashboard_controller.rb", "line_start": 44, "line_end": 44, "type": "code-style", "severity": "low", "title": "Hardcoded magic number for date range", "description": "Line 44 uses the literal 30.days.ago for the monthly task count, and line 21 uses the literal 7 for the weekly window. These magic numbers are scattered throughout the method with no named constants or configuration. If the business decides to change the 'recent' window from 30 to 14 days, or the weekly window to 5 business days, a developer must hunt through the controller to find and update each occurrence.", "hint": "Define named constants at the class level: WEEKLY_WINDOW = 7.days and MONTHLY_WINDOW = 30.days, then reference them in the queries. This makes the values discoverable, self-documenting, and easy to change."}
{"id": "09-008", "file": "app/views/dashboard/index.html.erb", "line_start": 118, "line_end": 118, "type": "bug", "severity": "low", "title": "Timezone-unaware date display in recent activity", "description": "Line 118 calls task.updated_at.to_date which converts the UTC timestamp to a date using Ruby's default system timezone, not the Rails-configured timezone or the user's local timezone. A task updated at 11pm Eastern (4am UTC next day) would display tomorrow's date. This is inconsistent with how Rails normally handles time display via l() or I18n.l().", "hint": "Use task.updated_at.in_time_zone.to_date for timezone-aware conversion, or use Rails' built-in time formatting: l(task.updated_at, format: :short) which respects I18n and time zone settings."}
